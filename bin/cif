#!/usr/bin/env python
# encoding: utf-8

import sys
import os
import os.path
import cif.sdk
from cif.sdk.client import Client
from prettytable import PrettyTable
import yaml
import logging
import traceback
import select
import pprint
pp = pprint.PrettyPrinter()

from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter

__all__ = []
__version__ = cif.sdk.__version__
__date__ = '2014-05-19'
__updated__ = '2014-05-19'
__max_field_size__ = 30

class CLIError(Exception):
    '''Generic exception to raise and log different fatal errors.'''
    def __init__(self, msg):
        super(CLIError).__init__(type(self))
        self.msg = "E: %s" % msg
    def __str__(self):
        return self.msg
    def __unicode__(self):
        return self.msg

def make_table(r):
    ##TODO factory this out with snort rule, etc
    cols = ['tlp','group','reporttime','observable','cc','asn','asn_desc','confidence','tags','rdata','provider']
    
    t = PrettyTable(cols)
    t.align['provider'] = 'l'
    if type(r) is not list:
        r = [r]
    
    for obs in r:
        r = []
        for c in cols:
            y = obs.get(c) or ''
            if type(y) is list:
                y = ','.join(y)

            # http://stackoverflow.com/questions/3224268/python-unicode-encode-error
            # http://stackoverflow.com/questions/19833440/unicodeencodeerror-ascii-codec-cant-encode-character-u-xe9-in-position-7
            if type(y) is unicode:
                y = y.encode('ascii', 'ignore')

            y = str(y)
            y = (y[:__max_field_size__] + '..') if len(y) > __max_field_size__ else y
            r.append(y)
        t.add_row(r)
    print t
    ## END
    
def main(argv=None): # IGNORE:C0111
    '''Command line options.'''
    
    if argv is None:
        argv = sys.argv
    else:
        sys.argv.extend(argv)

    program_name = os.path.basename(sys.argv[0])
    program_version = "v%s" % __version__
    program_build_date = str(__updated__)
    program_version_message = '%%(prog)s %s (%s)' % (program_version, program_build_date)

    try:
        # Setup argument parser
        parser = ArgumentParser(description='', formatter_class=RawDescriptionHelpFormatter)
        parser.add_argument("-v", "--verbose", dest="verbose", action="count", help="set verbosity level [default: %(default)s]")
        parser.add_argument('-d', '--debug', dest='debug', action="store_true")
        parser.add_argument('-q',"--search", dest="search", help="search for observable")
        parser.add_argument('--firsttime', dest='firsttime', help='firsttime or later')
        parser.add_argument('--lasttime', dest='lasttime', help='lasttime or earlier')
        parser.add_argument('--reporttime',dest='reporttime', help='TODO')
        parser.add_argument('--reporttimeend',dest='reporttimeend',help='TODO')
        parser.add_argument("--tags", dest="tags", help="filter for tags")
        parser.add_argument('--otype', dest='otype', help='filter by otype')
        parser.add_argument("--cc", dest="cc", help="filter for countrycode")
        parser.add_argument('--token', dest='token', help="specify token")
        parser.add_argument('--confidence', dest="confidence", help="specify confidence")
        parser.add_argument('--rdata',dest='rdata', help='filter by rdata')
        parser.add_argument('--limit', dest="limit", help="result limit", default=500)
        parser.add_argument('--no-verify-ssl', dest="no_verify_ssl", action="store_true", default=False)
        parser.add_argument('--remote', dest="remote", help="remote api location (eg: https://example.com)")
        parser.add_argument('--timeout', dest="timeout", help='connection timeout [default: %(default)s]', default="300")
        parser.add_argument('-C', '--config', dest="config", help="configuration file [default: %(default)s]", default=os.path.expanduser("~/.cif.yml") )
        parser.add_argument('-p','--ping', dest="ping", action="store_true", help="ping")
        parser.add_argument('--sort',dest='sort',help='sort output ASC by key',default='reporttime')
        parser.add_argument('--submit', help="submit json string")
        parser.add_argument('-V', '--version', action='version', version=program_version_message)
        parser.add_argument('-n', '--nolog', help='do not log the search', default=None, action="store_true")
        parser.add_argument('--provider', dest='provider', help='filter by provider')
        
        # Process arguments
        args = parser.parse_args()
        
        # setup the initial console logging
        fmt = '%(asctime)s - %(levelname)s - %(name)s::%(threadName)s - %(message)s'
        loglevel = logging.WARNING
        if args.verbose:
            loglevel = logging.INFO
        if args.debug:
            loglevel = logging.DEBUG
        
        console = logging.StreamHandler()
        logging.getLogger('').setLevel(loglevel)
        console.setFormatter(logging.Formatter(fmt))
        logging.getLogger('').addHandler(console)
        logger = logging.getLogger(__name__)

        options = vars(args)

        if os.path.isfile(args.config):
            f = file(args.config)
            config = yaml.load(f)
            f.close()
            if not config['client']:
                raise Exception("Unable to read " + args.config + " config file")
            config = config['client']
            for k in config:
                if not options.get(k):
                    options[k] = config[k]
        
        if(options.get('search') or options.get('tags') or options.get('cc') or options.get('rdata') or options.get('otype')):
            filters = {}
            if options.get('search'):
                filters['observable'] = options['search']
            if options.get('cc'):
                filters['cc'] = options['cc']
            
            if options.get('tags'):
                filters['tags'] = options['tags']
                
            if options.get('confidence'):
                filters['confidence'] = options['confidence']
                
            if options.get('firsttime'):
                filters['firsttime'] = options['firsttime']
            
            if options.get('lasttime'):
                filters['lasttime'] = options['lasttime']

            if options.get('reporttime'):
                filters['reporttime'] = options['reporttime']

            if options.get('reporttimeend'):
                filters['reporttimeend'] = options['reporttimeend']
                
            if options.get('otype'):
                filters['otype'] = options['otype']
            
            if options.get('rdata'):
                filters['rdata'] = options['rdata']
            
            if options.get('nolog'):
                options['nolog'] = 1

            if options.get('provider'):
                filters['provider'] = options['provider']
                
            ret = Client(**options).search(limit=options['limit'],nolog=options['nolog'],filters=filters,sort=options.get('sort'))
            make_table(ret)
        elif(options.get('ping')):
            for num in range(0,4):
                ret = Client(**options).ping()
                print "roundtrip: %s ms" % ret
                select.select([],[],[],1) ## TODO -- does this work on windows?
        elif(options.get('submit')):
            ret = Client(**options).submit(**options)
            make_table(ret)
        else:
            logger.warning('operation not supported')
            sys.exit()

    except KeyboardInterrupt:
        ### handle keyboard interrupt ###
        return 0
    except Exception, e:
        traceback.print_exc(file=sys.stdout)
        indent = len(program_name) * " "
        sys.stderr.write(program_name + ": " + repr(e) + "\n")
        sys.stderr.write(indent + "  for help use --help")
        return 2

if __name__ == "__main__":
    sys.exit(main())
